// generate deterministic config.ts from schema
// why: produce typed runtime config
// how: inline tiny validators and map entries to expressions
import { EnvSchema, SchemaEntry } from './parser';

// header banner
function emitHeader(): string {
  return '/* auto-generated by envsaurus */\n';
}

// inline minimal validators (keep size tiny, no imports)
function emitValidatorsInline(): string {
  return (
    "function asNumber(x, k=''){ if(!x&&x!==0) throw new Error(`${k} required`); const n=+x; if(Number.isNaN(n)) throw new Error(`${k} must be number`); return n; }\n" +
    "function asBool(x){ if(x==null||x==='') return false; const v=String(x).toLowerCase(); return v==='1'||v==='true'||v==='yes'||v==='on'; }\n" +
    "function asEnum(x,k,opts){ if(!x||!opts.includes(x)) throw new Error(`${k} must be one of ${opts.join(',')}`); return x; }\n" +
    "function asURL(x,k=''){ try { return new URL(String(x)).toString(); } catch { throw new Error(`${k} must be a valid URL`); } }\n" +
    "function asEmail(x,k=''){ const re=/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/; if(!x||!re.test(x)) throw new Error(`${k} must be a valid email`); return x; }\n" +
    "function asJSON(x,k=''){ try { return JSON.parse(String(x)); } catch { throw new Error(`${k} must be valid JSON`); } }\n"
  );
}

// map one schema entry to JS expression
function jsString(value: string | undefined): string | undefined {
  return value === undefined ? undefined : JSON.stringify(value);
}

function emitEntry(e: SchemaEntry): string {
  const k = e.key;
  switch (e.type) {
    case 'number':
      return `${k}: asNumber(process.env.${k} ?? ${jsString(e.defaultValue) ?? 'undefined'}, '${k}')`;
    case 'boolean':
      return `${k}: asBool(process.env.${k} ?? ${jsString(e.defaultValue ?? '')})`;
    case 'enum':
      return `${k}: asEnum(process.env.${k} ?? ${jsString(e.defaultValue) ?? 'undefined'}, '${k}', [${(e.enumValues || []).map((s) => `'${s}'`).join(',')}])`;
    case 'url':
      return `${k}: asURL(process.env.${k} ?? ${jsString(e.defaultValue) ?? 'undefined'}, '${k}')`;
    case 'email':
      return `${k}: asEmail(process.env.${k} ?? ${jsString(e.defaultValue) ?? 'undefined'}, '${k}')`;
    case 'json':
      return `${k}: asJSON(process.env.${k} ?? ${jsString(e.defaultValue) ?? 'undefined'}, '${k}')`;
    case 'string':
    default:
      return `${k}: (process.env.${k} ?? ${e.defaultValue !== undefined ? JSON.stringify(e.defaultValue) : "''"})`;
  }
}

export function generateConfigTs(schema: EnvSchema): string {
  const body = schema.entries.map(emitEntry).join(',\n  ');
  return (
    emitHeader() +
    emitValidatorsInline() +
    'export const CONFIG = {\n' +
    `  ${body}\n` +
    '} as const;\n'
  );
}

// generate CommonJS JS with JSDoc typedef
export function generateConfigJs(schema: EnvSchema): string {
  const fields: string[] = [];
  for (const e of schema.entries) {
    let t: string;
    switch (e.type) {
      case 'number':
        t = 'number';
        break;
      case 'boolean':
        t = 'boolean';
        break;
      case 'enum':
        t =
          e.enumValues && e.enumValues.length
            ? e.enumValues.map((v) => `'${v}'`).join(' | ')
            : 'string';
        break;
      case 'url':
        t = 'string';
        break;
      case 'email':
        t = 'string';
        break;
      case 'json':
        t = 'any';
        break;
      case 'string':
      default:
        t = 'string';
        break;
    }
    fields.push(` * @property {${t}} ${e.key}`);
  }
  const typedef =
    '/**\n * @typedef {Object} Config\n' + fields.join('\n') + '\n */\n';
  const body = schema.entries.map(emitEntry).join(',\n  ');
  return (
    emitHeader() +
    emitValidatorsInline() +
    typedef +
    '/** @type {Config} */\n' +
    'const CONFIG = {\n' +
    `  ${body}\n` +
    '};\n' +
    'module.exports = { CONFIG };\n'
  );
}
